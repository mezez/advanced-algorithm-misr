The objective of this project was to implement some algorithms for solving the Traveling Salesman Problem (TSP) and to provide an experimental study of their running time and quality.
The travelling salesman man problem seeks to find the shortest possible route that visits each city (tour) exactly once and then returns to the origin city, given a list of cities( or points) and the distances between each pair of cities.. This problem is generally NP hard as the worst case computation time for finding a solution will polynomially increase as more cities are added to a tour.
This algorithm takes as input a collection of locations or nodes and the distances between these nodes or in more precise contexts, a cost matrix of travelling between the given nodes.


This project group specifically worked on the TSP approaches stated below:
-The Brute Force approach
-The Branch and Bound approach
-The Approximation Based on a Minimum Spanning Tree approach
-The Greedy approach
-The Dynamic Programming approach
-The Genetic Programming approach
-The Ant Colony Optimization approach and 
-The 2-Opt Algorithm approach

**PROGRAMS EXECUTION GUIDE**
Programming Language: Python

**Project Structure**:
  -A gui.py file containing the Gui Class which is the entry point into the application from which all the algorithms can be executed.
  -The source files for all the algorithms are directly under the main project folder. The only exception is the 2 Opt algorithm which has a main file in the general folder but    uses abstractions bundled into a package that can be found under the pyTwoOpt folder. This folder is also under the parent folder.
  -A util.py file which contains the algorithm for parsing dynamic TSP databases from a .xlsx Excel file in the form of a N x N matrix or a list of X and Y coordinates.
  -A tsp_db folder under the parent folder. This contains different variants of the bays29 problem, the ulysses16, ulysses22 and many other problems  from the tsp database at      http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/
  -A requirements.txt file which can be used for installing all the dependencies for the project. This can also be done using inbuilt Integrated Development Environment (IDE)      features.

**Programsâ€™ execution**:
  The application can be run by running the gui.py class file. This spins up the GUI application. The GUI has a toggle button for switching between running individual algorithms   or for running all the algorithms (suitable in cases where comparison is important). The GUI also has different tabs for setting the active algorithm to execute (in the case     of running single algorithms). The default algorithm is the Genetic Algorithm.

After setting the active algorithm, the next stage is the input.
Input:
  The input of the system is an N X N cost matrix between cities. This can either:
  Be generated randomly by entering the a number for N and specifying bounds for controlled outputs or
  Parsed by uploading an excel file containing STRICTLY  an N X N cost matrix or a list of STRICTLY X and Y coordinates  of a TSP problem.

Once the Generate Random Matrix button is clicked for the random generator or the upload is done for the parsing option, the computation starts automatically.

Output: The output of the program includes:
  For the single algorithm execution
    -The Minimum Cost of the computation
    -The Path Taken
    -The time taken for computation in seconds and finally
    -The generated or parsed matrix
  For the all algorithms execution
    -A chart of all the costs generated by the different algorithms
    -A chart of all the execution time taken by the different algorithms
    -The generated or parsed matrix

**NOTE**: For the parameter based algorithms, the number of iterations is set to 500 as default.  Changing this value will definitely have an effect on the performance and results of these algorithms. The default value can be changed simply by searching for iterations or 500 in the ant_colony_optimization.py, py2opt.py and genetic_approach.py files in the root directory.
